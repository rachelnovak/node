"use strict";
///////////////////////////////////////////////////////////////////////////////
//
// Licensed under the Apache License, Version 2.0  ( the  "License" );  you may 
// not use this file except in compliance with the License.  You may  obtain  a 
// copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required  by  applicable  law  or  agreed  to  in  writing,  software 
// distributed under the License is distributed on an "AS  IS"  BASIS,  WITHOUT
// WARRANTIES OR CONDITIONS  OF  ANY  KIND, either express or implied.  See the 
// License for the specific  language  governing  permissions  and  limitations 
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
function* Forward(target) {
    yield* target;
}
exports.Forward = Forward;
function* Reverse(target) {
    for (let i = target.length - 1; i >= 0; i--) {
        yield target[i];
    }
}
exports.Reverse = Reverse;
function* Select(target, transform) {
    let index = 0;
    for (let value of target) {
        yield transform(value, index++);
    }
}
exports.Select = Select;
function* DefaultIfEmpty(target, defaultValue) {
    let iterator = target[Symbol.iterator]();
    let result = iterator.next();
    if (result.done) {
        yield defaultValue;
    }
    else {
        yield* target;
    }
}
exports.DefaultIfEmpty = DefaultIfEmpty;
function* ChunkBy(target, keySelect, elementSelector, resultSelector) {
    let key, box, i = 0;
    for (let value of target) {
        let newKey = keySelect(value, i++);
        if (key !== newKey && box) {
            yield resultSelector(key, box);
            box = undefined;
        }
        if (!box) {
            box = new Array();
        }
        key = newKey;
        box.push(elementSelector(value));
    }
    if (box) {
        yield resultSelector(key, box);
    }
}
exports.ChunkBy = ChunkBy;
function* Distinct(target, keySelector) {
    let set = new Set();
    for (let value of target) {
        let key = keySelector(value);
        if (set.has(key))
            continue;
        set.add(key);
        yield value;
    }
}
exports.Distinct = Distinct;
function* DistinctFast(target) {
    let set = new Set();
    for (let value of target) {
        if (set.has(value))
            continue;
        set.add(value);
        yield value;
    }
}
exports.DistinctFast = DistinctFast;
function* OfType(target, obj, typeName) {
    if (typeName) {
        for (let value of target) {
            if (typeName == typeof (value)) {
                yield value;
            }
            else if (value instanceof obj) {
                yield value;
            }
        }
    }
    else {
        for (let value of target) {
            if (value instanceof obj) {
                yield value;
            }
        }
    }
}
exports.OfType = OfType;
function* Where(target, predicate) {
    let index = 0;
    for (let value of target) {
        if (!predicate(value, index++))
            continue;
        yield value;
    }
}
exports.Where = Where;
function* Skip(target, skip) {
    let index = 0;
    for (let value of target) {
        if (skip > index++)
            continue;
        yield value;
    }
}
exports.Skip = Skip;
function* SkipWhile(target, predicate) {
    let index = 0, skipped = false;
    for (let value of target) {
        if (!skipped && !(skipped = !predicate(value, index++)))
            continue;
        yield value;
    }
}
exports.SkipWhile = SkipWhile;
function* TakeWhile(target, predicate) {
    let index = 0;
    for (let value of target) {
        if (!predicate(value, index++))
            break;
        yield value;
    }
}
exports.TakeWhile = TakeWhile;
function* Intersect(target, exceptions, condition, keySelect) {
    if (keySelect) {
        for (let value of target) {
            if (condition == exceptions.has(keySelect(value)))
                continue;
            yield value;
        }
    }
    else {
        for (let value of target) {
            if (condition == exceptions.has(value))
                continue;
            yield value;
        }
    }
}
exports.Intersect = Intersect;
function* Repeat(value, count) {
    for (let i = 0; i < count; i++) {
        yield value;
    }
}
exports.Repeat = Repeat;
function* Range(value, count) {
    let current = value;
    for (let i = 0; i < count; i++) {
        yield current;
        current++;
    }
}
exports.Range = Range;
function* Union(first, second, keySelector) {
    let set = new Set();
    for (let value of first) {
        let key = keySelector(value);
        if (set.has(key))
            continue;
        set.add(key);
        yield value;
    }
    for (let value of second) {
        let key = keySelector(value);
        if (set.has(key))
            continue;
        set.add(key);
        yield value;
    }
}
exports.Union = Union;
function* UnionFast(first, second) {
    let set = new Set();
    for (let value of first) {
        if (set.has(value))
            continue;
        set.add(value);
        yield value;
    }
    for (let value of second) {
        if (set.has(value))
            continue;
        set.add(value);
        yield value;
    }
}
exports.UnionFast = UnionFast;
function* Join(target, oKeySelect, transform, map) {
    for (let value of target) {
        let key = oKeySelect(value);
        if (!key)
            continue;
        let innerSet = map.get(key);
        if (!innerSet)
            continue;
        for (let inner of innerSet) {
            yield transform(value, inner);
        }
    }
}
exports.Join = Join;
function* GroupJoin(target, oKeySelect, transform, map) {
    for (let value of target) {
        let innerSet = undefined;
        let key = oKeySelect(value);
        if (key) {
            innerSet = map.get(key);
        }
        yield transform(value, innerSet);
    }
}
exports.GroupJoin = GroupJoin;
function* GroupBy(map, resultSelect) {
    for (let key of map.keys()) {
        yield resultSelect(key, map.get(key));
    }
}
exports.GroupBy = GroupBy;
function* SelectMany(target, selector, transform) {
    let index = 0;
    for (let item of target) {
        for (let collectionItem of selector(item, index++)) {
            yield transform(item, collectionItem);
        }
    }
}
exports.SelectMany = SelectMany;
function* Concat(target, second) {
    yield* target;
    yield* second;
}
exports.Concat = Concat;
function* Zip(first, second, transform, _index = 0) {
    let iteratorOne = first[Symbol.iterator]();
    let iteratorTwo = second[Symbol.iterator]();
    let retOne, retTwo;
    while (!(retOne = iteratorOne.next()).done && !(retTwo = iteratorTwo.next()).done) {
        yield transform(retOne.value, retTwo.value);
    }
}
exports.Zip = Zip;
/** Copyright (c) ENikS.  All rights reserved. */
//# sourceMappingURL=generators.js.map