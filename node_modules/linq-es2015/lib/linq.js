"use strict";
///////////////////////////////////////////////////////////////////////////////
//
// Licensed under the Apache License, Version 2.0  ( the  "License" );  you may 
// not use this file except in compliance with the License.  You may  obtain  a 
// copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required  by  applicable  law  or  agreed  to  in  writing,  software 
// distributed under the License is distributed on an "AS  IS"  BASIS,  WITHOUT
// WARRANTIES OR CONDITIONS  OF  ANY  KIND, either express or implied.  See the 
// License for the specific  language  governing  permissions  and  limitations 
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const Generator = require("./generators");
const Constant = require("./utilities");
const Iterator = require("./iterators");
//-----------------------------------------------------------------------------
//  Implementation of EnumerableConstructor interface
//-----------------------------------------------------------------------------
/**
* Converts any Iterable<T> object into LINQ-able object
* @param TSource An Array, Map, Set, String or other Iterable object.
*/
function getEnumerable(TSource) {
    return new EnumerableImpl(TSource);
}
exports.default = getEnumerable;
exports.AsEnumerable = getEnumerable;
exports.asEnumerable = getEnumerable;
exports.From = getEnumerable;
exports.from = getEnumerable;
/**
* Generates <count> of <T> elements starting with <start>. T is any
* type which could be cast to number: number, enum, etc.
* @param start First value in sequence.
* @param count Number of elements to iteratel.
* @example
*     var sum = Range(0, 7).Sum();
*/
function getRange(start, count) {
    return new EnumerableImpl(undefined, Generator.Range, [start, count]);
}
exports.range = getRange;
exports.Range = getRange;
/**
* Repeat element <start> of type T <count> of times.
* @param start First value in sequence.
* @param count Number of elements to iteratel.
* @example
*     var sum = Repeat("v", 7);
*/
function getRepeat(value, count) {
    return new EnumerableImpl(undefined, Generator.Repeat, [value, count]);
}
exports.repeat = getRepeat;
exports.Repeat = getRepeat;
//-----------------------------------------------------------------------------
//  Enumerable Implementation
//-----------------------------------------------------------------------------
class EnumerableImpl {
    constructor(target, factory, arg) {
        this._target = target;
        this._factory = factory;
        this._factoryArg = arg;
        // JavaScript naming convention
        this['aggregate'] = this.Aggregate;
        this['all'] = this.All;
        this['any'] = this.Any;
        this['average'] = this.Average;
        this['chunkBy'] = this.ChunkBy;
        this['contains'] = this.Contains;
        this['count'] = this.Count;
        this['max'] = this.Max;
        this['min'] = this.Min;
        this['elementAt'] = this.ElementAt;
        this['elementAtOrDefault'] = this.ElementAtOrDefault;
        this['first'] = this.First;
        this['firstOrDefault'] = this.FirstOrDefault;
        this['last'] = this.Last;
        this['lastOrDefault'] = this.LastOrDefault;
        this['sequenceEqual'] = this.SequenceEqual;
        this['single'] = this.Single;
        this['singleOrDefault'] = this.SingleOrDefault;
        this['sum'] = this.Sum;
        this['toArray'] = this.ToArray;
        this['toMap'] = this.ToMap;
        this['toDictionary'] = this.ToDictionary;
        this['defaultIfEmpty'] = this.DefaultIfEmpty;
        this['concat'] = this.Concat;
        this['distinct'] = this.Distinct;
        this['except'] = this.Except;
        this['groupBy'] = this.GroupBy;
        this['groupJoin'] = this.GroupJoin;
        this['intersect'] = this.Intersect;
        this['join'] = this.Join;
        this['ofType'] = this.OfType;
        this['orderBy'] = this.OrderBy;
        this['orderByDescend'] = this.OrderByDescending;
        this['range'] = this.Range;
        this['repeat'] = this.Repeat;
        this['reverse'] = this.Reverse;
        this['select'] = this.Select;
        this['selectMany'] = this.SelectMany;
        this['skip'] = this.Skip;
        this['skipWhile'] = this.SkipWhile;
        this['take'] = this.Take;
        this['takeWhile'] = this.TakeWhile;
        this['union'] = this.Union;
        this['where'] = this.Where;
        this['zip'] = this.Zip;
    }
    ///////////////////////////////////////////////////////////////////////////
    /** Returns JavaScript iterator */
    [Symbol.iterator]() {
        return (null != this._factory) ? this._factory.apply(this, this._factoryArg)
            : this._target[Symbol.iterator]();
    }
    /** Returns C# style enumerator */
    GetEnumerator() {
        return new Iterator.CSharpEnumerator(this[Symbol.iterator]());
    }
    Aggregate(alpha, beta = Constant.selfFn, gamma = Constant.selfFn) {
        let zero;
        let method;
        let selector;
        if (Constant.CONST_FUNCTION === typeof alpha) {
            method = alpha;
            selector = beta;
        }
        else {
            zero = alpha;
            method = beta;
            selector = gamma;
        }
        let result = zero;
        for (let value of this) {
            if (!result)
                result = Constant.getDefaultVal(typeof (value));
            result = method(result, value);
        }
        return selector(result);
    }
    All(predicate = Constant.trueFn) {
        for (let value of this) {
            if (!predicate(value)) {
                return false;
            }
        }
        return true;
    }
    Any(predicate) {
        let iterator;
        // Check if at least one exist
        if (!predicate && (iterator = this[Symbol.iterator]())) {
            return !iterator.next().done;
        }
        // Check if any satisfy the criteria
        for (let value of this) {
            if (predicate(value)) {
                return true;
            }
        }
        return false;
    }
    Average(func = Constant.selfFn) {
        let sum = 0, count = 0;
        for (let value of this) {
            sum += func(value);
            count++;
        }
        return sum / count;
    }
    Contains(value, equal = (a, b) => a === b) {
        for (let item of this) {
            if (equal(item, value)) {
                return true;
            }
        }
        return false;
    }
    Count(predicate) {
        let count = 0;
        if (predicate) {
            for (let value of this) {
                if (predicate(value)) {
                    count++;
                }
            }
        }
        else if (this._target && this._target[Constant.CONST_LENGTH]) {
            count = this._target[Constant.CONST_LENGTH];
        }
        else {
            for (let value of this) {
                count++;
            }
        }
        return count;
    }
    Max(transform = Constant.selfFn) {
        let value, max, hasValue = false;
        for (let item of this) {
            value = transform(item);
            if (hasValue) {
                if (max < value)
                    max = value;
            }
            else {
                max = value;
                hasValue = true;
            }
        }
        if (!hasValue)
            throw Constant.CONST_NO_ELEMENTS;
        return max;
    }
    Min(transform = Constant.selfFn) {
        let value, min, hasValue = false;
        for (let item of this) {
            value = transform(item);
            if (hasValue) {
                if (min > value)
                    min = value;
            }
            else {
                min = value;
                hasValue = true;
            }
        }
        if (!hasValue)
            throw Constant.CONST_NO_ELEMENTS;
        return min;
    }
    ElementAt(index) {
        if (Array.isArray(this._target)) {
            if (0 > index ||
                this._target[Constant.CONST_LENGTH] <= index) {
                throw Constant.CONST_OUTOFRANGE;
            }
            return this._target[index];
        }
        let count = 0;
        for (let value of this) {
            if (index > count++) {
                continue;
            }
            return value;
        }
        throw Constant.CONST_OUTOFRANGE;
    }
    ElementAtOrDefault(index) {
        if (Array.isArray(this._target)) {
            let length = this._target[Constant.CONST_LENGTH];
            if (0 > index || length <= index) {
                let value = this._target[0];
                return 0 < length
                    ? Constant.getDefaultVal(typeof (value), value)
                    : undefined;
            }
            return this._target[index];
        }
        let value, count = 0;
        for (let item of this) {
            if (index === count++) {
                return item;
            }
            value = item;
        }
        return Constant.getDefaultVal(typeof value, value); // Last good value
    }
    First(predicate = Constant.trueFn) {
        for (let value of this) {
            if (predicate(value)) {
                return value;
            }
        }
        throw Constant.CONST_NOTHING_FOUND;
    }
    FirstOrDefault(predicate = Constant.trueFn) {
        let value;
        for (let item of this) {
            value = item;
            if (predicate(item)) {
                return item;
            }
        }
        return Constant.getDefaultVal(typeof value); // Last good value
    }
    Last(predicate = Constant.trueFn) {
        let value, found = false;
        for (let item of this) {
            if (predicate(item)) {
                value = item;
                found = true;
            }
        }
        if (!found) {
            throw Constant.CONST_NOTHING_FOUND;
        }
        return value;
    }
    LastOrDefault(predicate = Constant.trueFn) {
        let value, lastKnown, found = false;
        for (let item of this) {
            if (predicate(item)) {
                value = item;
                found = true;
            }
            lastKnown = item;
        }
        return (found) ? value : Constant.getDefaultVal(typeof lastKnown);
    }
    SequenceEqual(other, equal = (a, b) => a === b) {
        let res1, res2;
        let it1 = this[Symbol.iterator]();
        let it2 = other[Symbol.iterator]();
        while (true) {
            res1 = it1.next();
            res2 = it2.next();
            if (res1.done && res2.done)
                return true;
            if ((res1.done != res2.done) || !equal(res1.value, res2.value)) {
                return false;
            }
        }
        ;
    }
    Single(predicate = Constant.trueFn) {
        let value, hasValue = false;
        for (let item of this) {
            if (predicate(item)) {
                if (!hasValue) {
                    value = item;
                    hasValue = true;
                }
                else {
                    throw Constant.CONST_TOO_MANY;
                }
            }
        }
        if (hasValue)
            return value;
        throw Constant.CONST_NOTHING_FOUND;
    }
    SingleOrDefault(predicate = Constant.trueFn) {
        let value, lastKnown, hasValue = false;
        for (let item of this) {
            if (predicate(item)) {
                if (!hasValue) {
                    value = item;
                    hasValue = true;
                }
                else {
                    throw Constant.CONST_TOO_MANY;
                }
            }
            lastKnown = item;
        }
        return (hasValue) ? value : Constant.getDefaultVal(typeof lastKnown);
    }
    Sum(transform = Constant.selfFn) {
        let sum = 0;
        for (let value of this) {
            sum += transform(value);
        }
        return sum;
    }
    ToArray() {
        let array = [];
        for (let value of this) {
            array.push(value);
        }
        return array;
    }
    ToMap(keySelector, elementSelector = Constant.selfFn) {
        let dictionary = new Map();
        for (let value of this) {
            dictionary.set(keySelector(value), elementSelector(value));
        }
        return dictionary;
    }
    ToDictionary(keySelector, elementSelector = Constant.selfFn) {
        let dictionary = new Map();
        for (let value of this) {
            dictionary.set(keySelector(value), elementSelector(value));
        }
        return dictionary;
    }
    Cast() {
        // TODO: Remove any once TypeScript 2.0 out
        return this;
    }
    //-------------------------------------------------------------------------
    //  Deferred execution methods
    //-------------------------------------------------------------------------
    DefaultIfEmpty(defaultValue = undefined) {
        return new EnumerableImpl(undefined, Generator.DefaultIfEmpty, [this, defaultValue]);
    }
    Concat(second) {
        return new EnumerableImpl(undefined, Generator.Concat, [this, second]);
    }
    ChunkBy(keySelect, elementSelector = Constant.selfFn, resultSelector = (a, b) => b) {
        return new EnumerableImpl(undefined, Generator.ChunkBy, [this, keySelect, elementSelector, resultSelector]);
    }
    Distinct(keySelector) {
        if (keySelector)
            return new EnumerableImpl(undefined, Generator.Distinct, [this, keySelector]);
        return new EnumerableImpl(undefined, Generator.DistinctFast, [this]);
    }
    Except(other, keySelector) {
        return new EnumerableImpl(undefined, Generator.Intersect, [this, Constant.getKeys(other, keySelector), true, keySelector]);
    }
    GroupBy(selKey, selElement = Constant.selfFn, selResult = Constant.defGrouping) {
        let map = Constant.getKeyedMap(this, selKey, selElement);
        return new EnumerableImpl(undefined, Generator.GroupBy, [map, selResult]);
    }
    GroupJoin(inner, oKeySelect, iKeySelect, resultSelector = Constant.defGrouping) {
        return new EnumerableImpl(undefined, Generator.GroupJoin, [this, oKeySelect, resultSelector,
            Constant.getKeyedMapFast(inner, iKeySelect)]);
    }
    Intersect(other, keySelector) {
        return new EnumerableImpl(undefined, Generator.Intersect, [this,
            Constant.getKeys(other, keySelector),
            false, keySelector]);
    }
    Join(inner, oSelector, iSelector, transform) {
        return new EnumerableImpl(undefined, Generator.Join, [this, oSelector, transform, Constant.getKeyedMapFast(inner, iSelector)]);
    }
    OfType(obj) {
        let typeName;
        switch (obj) {
            case Number:
                typeName = Constant.CONST_NUMBER;
                break;
            case Boolean:
                typeName = Constant.CONST_BOOLEAN;
                break;
            case String:
                typeName = Constant.CONST_STRING;
                break;
            case Symbol:
                typeName = Constant.CONST_SYMBOL;
                break;
            default:
                typeName = undefined;
        }
        return new EnumerableImpl(undefined, Generator.OfType, [this, obj, typeName]);
    }
    OrderBy(keySelect, equal) {
        return new OrderedLinq(this, (array) => Generator.Forward(array), keySelect, equal);
    }
    OrderByDescending(keySelect, equal) {
        return new OrderedLinq(this, (array) => Generator.Reverse(array), keySelect, equal, true);
    }
    Range(start, count) {
        return new EnumerableImpl(undefined, Generator.Range, [start, count]);
    }
    Repeat(element, count) {
        return new EnumerableImpl(undefined, Generator.Repeat, [element, count]);
    }
    Reverse() {
        let array = Array.isArray(this._target)
            ? this._target : this.ToArray();
        return new EnumerableImpl(undefined, Generator.Reverse, [array]);
    }
    Select(transform) {
        return new EnumerableImpl(undefined, Generator.Select, [this, transform]);
    }
    SelectMany(selector = Constant.selfFn, result = (x, s) => s) {
        return new EnumerableImpl(undefined, Generator.SelectMany, [this, selector, result]);
    }
    Skip(skip) {
        return new EnumerableImpl(undefined, Generator.Skip, [this, skip]);
    }
    SkipWhile(predicate) {
        return new EnumerableImpl(undefined, Generator.SkipWhile, [this, predicate]);
    }
    Take(take) {
        return new EnumerableImpl(undefined, Generator.TakeWhile, [this, (a, n) => take > n]);
    }
    TakeWhile(predicate) {
        return new EnumerableImpl(undefined, Generator.TakeWhile, [this, predicate]);
    }
    Union(second, keySelector) {
        if (keySelector)
            return new EnumerableImpl(undefined, Generator.Union, [this, second, keySelector]);
        return new EnumerableImpl(undefined, Generator.UnionFast, [this, second]);
    }
    Where(predicate = Constant.trueFn) {
        return new EnumerableImpl(undefined, Generator.Where, [this, predicate]);
    }
    Zip(second, func) {
        return new EnumerableImpl(undefined, Generator.Zip, [this, second, func]);
    }
}
class OrderedLinq extends EnumerableImpl {
    constructor(target, factory, keySelect, equal, reversed = false) {
        super(target, factory);
        this.reversed = reversed;
        if (keySelect) {
            this.comparer = equal ? (a, b) => equal(keySelect(a), keySelect(b))
                : (a, b) => Constant.defCompare(keySelect(a), keySelect(b));
        }
        else {
            this.comparer = equal;
        }
        this['thenBy'] = this.ThenBy;
        this['thenByDescending'] = this.ThenByDescending;
    }
    [Symbol.iterator]() {
        if (!this._factoryArg) {
            this._factoryArg = this._target.ToArray();
            if (this.comparer) {
                this._factoryArg.sort(this.comparer);
            }
            else {
                this._factoryArg.sort();
            }
        }
        return this._factory(this._factoryArg);
    }
    ThenBy(keySelect, equal) {
        if (!keySelect && !equal)
            return this;
        var compare = keySelect ? equal ? (a, b) => equal(keySelect(a), keySelect(b))
            : (a, b) => Constant.defCompare(keySelect(a), keySelect(b))
            : equal;
        if (!this.comparer) {
            this.comparer = compare;
        }
        else {
            let superEqual = this.comparer;
            this.comparer = (a, b) => {
                let result = superEqual(a, b);
                return (0 != result) ? result : this.reversed ? -compare(a, b) : compare(a, b);
            };
        }
        return this;
    }
    ThenByDescending(keySelect, equal) {
        if (!keySelect && !equal)
            return this;
        var compare = keySelect ? equal ? (a, b) => equal(keySelect(a), keySelect(b))
            : (a, b) => Constant.defCompare(keySelect(a), keySelect(b))
            : equal;
        if (!this.comparer) {
            this.comparer = compare;
        }
        else {
            let superEqual = this.comparer;
            this.comparer = (a, b) => {
                let result = superEqual(a, b);
                return (0 != result) ? result : this.reversed ? compare(a, b) : -compare(a, b);
            };
        }
        return this;
    }
}
/** Copyright (c) ENikS.  All rights reserved. */
//# sourceMappingURL=linq.js.map